


shell脚本开头要加入一句: #! /bin/bash(屎棒)
变量赋值符号中间都不可以有空格符
. + 文件 :表示执行该文件
shell中只有一种数据类型:string(字符串)
取出环境变量的值时,必须加上""号 如:echo "$var"
$(字符串):把该字符串当成命令执行,比如:$(ls)表示执行ls命令得到的结果
"$字符串":取出该变量的值

1.变量
变量名=变量值	#定义一个本地变量
export + 本地变量  #把本地变量导出(提升)为环境变量
unset+变量名	#删除本地变量
alias 名字='命令'	#给命令设置别名,相当于直接替换(直接alias为查看所有别名)

2.文件名替换
*	#匹配0个或多个字符
?	#匹配一个任意字符
[若干字符]	#匹配方括号中任意一个字符的一次出现,比如:[0-9].sh   可以匹配文件名为0.sh等

3.算术代换
利用反引号(esc键下方的键)可以直接执行命令,如:
	VAR=`date`
	echo "$VAR"
$[30+40]	#可以做运算,等于70
或
VAR=80
$[$VAR+90]	#可以得出值为170
进制运算
$[base#n]	#其中base表示进制,n表示该进制的数,后面再有运算符,而且没有进制表示的,按十进制解释
如:
echo $[2#10+10]	#值为12

4.转义字符
\(反斜杠)	#如 touch \$\ test.sh,这样才能正确创建文件(-号除外)
		#如 rm	  \$\ test.sh,这样才能正确删除文件
如何创建或者删除 - 符号开头的文件
	在文件名前面加上./,如: touch ./--new.c就可以创建一个文件名为--new.c的文件
	
5.条件测试(-d表示目录)
echo $?:查看上一个进程的返回值
test命令,如:test -f filename
[命令,如:[ -f filename ]
利用echo $?查看他们的真假,0为真,1为假
[ -d DIR ] 如果DIR存在并且是一个目录则为真
[ -f FILE ] 如果FILE存在且是一个普通文件则为真
[ -z STRING ] 如果STRING的长度为零则为真
[ -n STRING ] 如果STRING的长度非零则为真
[ STRING1 = STRING2 ] 如果两个字符串相同则为真
[ STRING1 != STRING2 ] 如果字符串不相同则为真
[ ARG1 OP ARG2 ] ARG1和ARG2应该是整数或者取值为整数的变量，OP是-eq（等于）-ne（不等于）-lt（小于）-le（小于等于）-gt（大于）-ge（大于等于）之中的一个

6.分支(if/then/elif/else/fi)
方法1:
if 条件测试; then
	满足条件执行的指令
elif 条件测试; then
	满足条件执行的指令
else
	执行的指令
fi	#条件分支结束标记符
或者
方法2:
if 条件测试
then
	满足条件执行的指令	#其余类似这个的写法
	
特殊的表示:
if :; then 执行的指令	#  :号类似于C语言的true

7.case/esac
case + 变量 + in	#与C语言的switch类似
匹配式) 
	执行的命令;;	#相当于case + 匹配式:执行的命令  ;;类似于break
*) 
	执行的命令;;	#相当于default
esac			#case结束

8.循环
for/do/done 循环
for FRUIT in apple banana pear; do	#FRUIT为循环变量 in后面的应该是集合
	echo "I like $FRUIT"
done
while循环
while 条件判断; do
	执行操作
done

9.位置参数和特殊变量
$0	#相当于C语言中main函数的argv[0]
$1,$2.. #相当于argv[1],argv[2]...
$#	#相当于C语言中argc-1
$@	#表示参数列表"$1","$2"...,比如可以用于: for var in $@
$*	#同上
$?	#表示上一条命令退出的状态
$$	#当前进程号
shift	#把参数列表左移($1开始的左移),丢弃

10.输入输出
echo	#显示文本行或变量,或者把字符串输入到文件中
echo [option] string
-e	#表示转义字符,比如: echo "hello \n",加-e会解析\n为换行
-n	#不回车换行.默认echo显示会有一个回车换行

tee
tee+输出为的文件	#比如: ls -a | tee out   会有两份数据的产生,一份输出到屏幕,一份到out文件中

文件重定向
cmd > file		#把标准输出重定向到新文件中
cmd >> file		#追加
cmd > file 2>&1		#把标准出错也重定向到标准输出中,由于前面的标准输出重定向为文件,所以把标准出错也重定向到文件中
cmd < file1 > file2	#把输入输出都重定向到文件
cmd < &fd		#把文件描述符fd作为标准输出
cmd < &-		#关闭标准输出

11.函数
函数名()
{
	#$1,$2,$3....在函数内表示函数的参数,除了$0(仍然为执行的进程名)以外,其余的都表示函数里面的参数或参数信息
	#指令集
}
函数名 参1 参2 参3...	#表示函数的调用  

12.正则表达式
	基础/basic正则表达式(小括号和大括号需要进行转义才能使用)
		在不支持直接使用扩展正则的命令中加入-E便可以使用,如:grep(egrep直接支持extend正则)
	扩展/extend正则表达式
		\1	表示第一个字符
		\2	表示第二个字符,如此类推
		字符类
		.	匹配任意一个字符
		[]	匹配括号中任意一个字符
		-	在[]括号中表示字符范围(如:[0-9][a-z]等)
		^	位于[]括号的开头,匹配出括号内字符以外的任意一个字符
		数量限定符
		?	紧跟在他前面的单元(不仅仅指字符)应匹配零次或一次
		+	紧跟在他前面的单元应匹配一次或多次
		*	紧跟他前面的单元匹配零次或多次
		{N,M}	紧跟他前面的单元应匹配至少N次,最多M次,同时还有({N},{N,},{,M})
		位置限定符
		^	匹配行首的位置(放在行首前面)
		$	匹配行末位置(放在行末后面)
		\<	匹配单词开头的位置(比如:\<th能匹配thread,不能匹配tenth)
		\>	匹配单词的结尾位置(比如:th\>能匹配tenth,不能匹配ethernet)
		\b	匹配单词开头或结尾的位置(比如:\bat\b,表示只匹配at单词)
		\B	匹配单词中间位置
		其他特殊字符
		\	转义字符,特殊转普通,普通转特殊
		()	将正则表达式的一部分括起来组成一个单元,然后就可以使用数量限定符
		|	连接两个子表达式,表示或的关系
	

13.sed工具(流编辑器):处理文件内容的行数据
	格式:	1.sed 参数 '脚本语句'/脚本文件 待操作文件1/文件2/文件 3			#以 ; 隔分多个脚本指令
			sed -i '4a **************************' re.txt	//在第四行追加************************
		2.sed 参数 -f '脚本文件' 待操作文件
	参数:
		-i:保存修改到文件中(默认为不保存)
		-n:默认情况下sed程序会自动输出一遍文件内容,加上该参数,屏蔽自动打印
		-r:默认为基础正则,加上参数后就支持扩展正则
	脚本语句中加入:
		a:追加   
		i:插入	sed -i "4i abcdefg" re.txt
		d:删除(删除多行  2,5d)	sed -i "5d" re.txt
		s:替换	sed -i 's/被替换的文本/替换的文本/g' re.txt  与vi中类似
			sed -i "s/txt/jk&jk/g" re.txt    #其中&符表示被替换的文本
			sed -r 's/([0-9])([0-9])/00\1~~--\2--/g' re.txt	#([0-9])必须加上括号,这样\1才能表示第一个单元,\2表示第二个单元
		p:输出搜索到的行 ,加上-n参数静默输出
		脚本中对行进行操作: sed "行号+标志位" 操作文件
		脚本中对内容的行进行操作: sed "/内容/标志位" 操作文件
		
14.awk工具:处理文件内容的列数据
	格式:	awk 参数 "脚本语句(/pattern/{action})"/文件 待操作文件
			awk '{print $2;}' testfile	#输出第二列内容,print表示输出,$2表示第二列,默认以空格或者制表符来划分
			awk '$2<75 {printf "%s\t%s",$0,"REORDER";} $2>=75 {print $0;} END {print "end"}' testfile	#格式
			(其中$0表示所有列内容,$1表示第一列,$2表示第二列,依次类推,END表示脚本执行结束,就执行他后面的语句)
			BEGIN: pattern 未匹配文件之前,执行某些操作
			END:   pattern 匹配文件结束,执行某些操作
 	参数
		-F+分隔符	表示以分隔符来进行划分列项(如:	-F:  表示以 : 为分隔符)	
		
15.
grep:

	 grep -R "struct task_struct {"  /usr/src/ -n

		
find:

	1. -name

		find ./ -name *.mp3

	2. -type
		
		find ./ -type f/d/p/c/b/s/l

	3. -size
		
		默认单位：512B-->0.5K-->一个扇区大小

		-M：不能m  find /home/itcast -size +3M -size -7M

		-k：不能K  find /home/itcast -size +47k -size -89k

		
	4. -maxdepth：

		find ./ -maxdepth 2 -type d 

	5. -exec、-ok

		find ./ -maxdepth 1 -name "*.sh" -exec rm -r {} \;	#把find得到的结果集直接放入缓冲区中,由rm进行操作

		find ./ -maxdepth 1 -name "*.sh" -ok rm -r {} \;

	7. xargs

		find ./ -maxdepth 1 -type f -print0 | xargs -0 ls -lh	#每次把部分结果放入缓冲区,处理完成便再导入

	6. -print0	#表示每条记录以\0结尾


	8. -atime  -- 访问时间
	   -amin

	   -mtime  -- 文件内容修改时间 比如:-mtime +5 表示5天以前,-5表示5天以内
	   -mmin

	   -ctime  -- 文件属性修改时间
	   -cmin
		 
		find ./ -name "syslog.*.gz" -mtime -5 -exec ls -lh {} \;
			


	



































