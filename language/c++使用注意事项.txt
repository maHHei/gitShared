																	《大要求：别返回一个在函数中创建的变量的地址》																		c/c++程序变成可执行程序的过程	1.预编译(gcc -e)		（1）将所有的#define删除，并且展开所有的宏定义。说白了就是字符替换		（2）处理所有的条件编译指令，#ifdef #ifndef #endif等，就是带#的那些		（3）处理#include，将#include指向的文件插入到该行处		（4）删除所有注释		（5）添加行号和文件标示，这样的在调试和编译出错的时候才知道是是哪个文件的哪一行		（6）保留#pragma编译器指令，因为编译器需要使用它们。	2.编译(gcc -c)		 编译的过程实质上是把高级语言翻译成机器语言的过程，即对a.c做了这些事儿		（1）词法分析，		（2）语法分析		（3）语义分析		（4）优化后生成相应的汇编代码		从 高级语言->汇编语言->机器语言（二进制）	3.链接(输出可执行文件)		但是编译过程只是把源文件翻译成二进制而已，这个二进制还不能直接执行，这个时候就需要做一个动作，		将翻译成的二进制与需要用到库绑定在一块。打个比方编译的过程就向你对你老婆说，我要吃雪糕。你只是给你老婆发出了你要吃		雪糕的诉求而已，但是雪糕还没有到。绑定就是说你要吃的雪糕你的老婆已经给你买了，你可以happy。		
	//利用auto_ptr<T>类来管理动态资源的释放，如：auto_ptr<Stuendt> ptr(create_Studnet()); //create_Studnet()返回一个Stuendt指针
	//静态成员变量初始化  类外初始化，如：Singlton *Singlton::Instance = NULL;//值是自己指定的，注意*的位置	大端和小端	/*		大端低字节存储高位（跟我们日常描述方式一样），小端高字节存储高位		影响：网络字节序是大端			union，C语言类型转换的时候	*/	普通函数和析构函数允许virtual，其他就不允许		vs动态库和静态库的使用	1.创建动态库		新建一个win32项目		选择dll和导出符号，其余默认		WIN32PROJECT1_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的（其中WIN32PROJECT1这部分替换为文件名便可，新的函数和新的类必须添加WIN32PROJECT1_API宏才能）	2.使用动态库		1.复制创建的项目的debug目录下的dll(程序运行时使用)和lib文件(程序链接时使用)，还有动态库的.h文件(编程时使用)		2.把lib和h文件粘贴到需要使用的项目的源文件处（与项目文件的.h和.cpp同一处）		3.dll文件粘贴到debug或者release目录下（总之与.exe文件同一个目录下就可以了）		4.添加依赖（头文件和lib文件依赖）：静态库和动态库都需要配置（他们的区别仅仅是何时导入程序）			设置库目录：vs--属性--链接器--常规--附加库目录--把lib文件所在目录填入（当然已经复制到目录下之后就不是必须添加的了）			设置库：vs---属性--链接器--输入--依赖项--把lib名字填入（这一步必须做）			设置头文件目录：vs--属性--VC++目录--包含目录--把头文件所在目录填入（当然已经复制到目录下之后就不是必须添加的了）		动态库和静态库的特点			静态库直接加载到程序当中的，所以运行速度较快，并且因为加载到可执行程序之中了，所以发布的时候不需要.lib文件了，但是相对来说体积也比较大			动态库与静态库是互补的	全缓冲，行缓冲和无缓冲（flush刷新缓冲）		1.全缓冲(_IOFBF)：当输入或者输出缓冲区被填满了，才会会进行实际I/O操作（对磁盘文件的操作通常是全缓冲的，write，read）		2.行缓冲(_IOLBF)：输入或输出缓冲区遇到换行符会进行实际的I/O读写操作。（printf，scanf）		3.无缓冲(_IONBF)：没有缓冲区，数据会立即读写进外存设备或者文件当中（stderr就是无缓冲的，保证错误实时反馈到用户）		设置缓冲区：			void setbuf(FILE *stream, char *buffer);//文件指针和缓冲区地址（可以设置为stdout,NULL 关闭输出缓冲区）			void setbuffer(FILE *stream, char *buf, size_t size);//与上基本一致，但可以指定缓冲区大小			int setvbuf(FILE *stream, char *buf, int mode, size_t size);//设置缓冲区类型				setvbuf(stream,NULL,_IOLBF,0);  //将缓冲改为行缓冲，可以这样设置的前提是存在缓冲区				setlinebuf(stream);  //在linux中，上面的代码等价于																																																																			
1.编码规则：每个字符序列总是以“合法符号序列”最长的解释，如：
vector< vector<int> > seq;中的“>>”是合法字符，所以会被解为两个>,所以得加空格。
2.区别何时应“&”和“*”，在对象可以为null时，便用point，不能为null便可以用reference符，其余的用法两者类似；
3.函数后的const表示不更动对象的中数据成员；
4.派生类的虚函数必须与基类的一模一样（除内容外），一般情况下，返回值必须相同，
有个例外：基类虚函数返回某个基类形式（通常是point或者reference），则派生类中虚拟函数可以返回派生类中相应的派生类型。
5.实现多态需要一层间接性，即reference或者point，普通的传参是无法实现多态的(想想其构模)
6.static_cast可将多态性型别进行无条件转换，如：
num_sequence *ps=&fib;
Fibonacci *pf=static_cast<Fibonacci *> (ps);
7.dynamic_cast(有条件的转换，会进行执行期校验操作)
8.当函数参数为class型别时，使用传址方式比传值大大节约时间(传址不需要创建一个新的变量，时间差)
9.c++规定，每个异常都要被处理
10.调用inline函数（由编译器处理）相当于把inline函数里面的内容复制到调用处（所以在函数过大时inline函数不划算）注意：内联函数必须跟函数体的实现（不是声明）写在一块
11.在函数中定义的变量，若最后以传址的方式返回，则会出错，为什么？该变量在函数结束时会被释放，
而指向该地址中的值已经不存在，所以会发生错误。
12.顶层硬件与软件打交道的接口是寄存器（读写硬件），寄存器上是一层简单的C语言接口
13.定义命名空间，如：
namespace namespaceA
{	int a;
}
namespace namespaceB{
	int a;
	namespace namespaceC{//命名空间嵌套定义	int a;
	}
}
14.heap而来的对象，是在执行期经过new表达式配置而来，声明周期直到delete表达式释放为止
15.类是一个抽象的概念，在定义的时候不分配内存，在定义该类型*对象*的时候才分配内存。
16.函数参数的默认值只能定义一次，在声明处或者定义处
17.不写成员函数一出现问题，如：
class{
	double r;
const double pi=3.14159;
double area=pi*r*r;//在初始化的时候已经执行赋值操作
}
在调用area时，并不执行pi*r*r操作了，所以得到的结果为乱码，如果调用成员函数就可以正确执行该操作
18.vector class提供内存自动管理机制
19.c++中关键字struct的的定义会被认为是一个新的类型，如：
struct Teacher{
	int age;
}; 
Teacher t1;//直接定义变量（C语言则不同，得加上struct）
20.struct关键字与class完成的功能是一样的，同样可以加上访问储存权限（如public，private，protected）
21.在变量要进行多次使用时（如 循环），会自动升级为register类型
22.c++变量和函数都必须有类型，C语言中默认的数据类型在c++中是不合法的
**23.C语言中表达式的返回值是储存在寄存器中（即返回一个值，不可修改），c++中，表达式返回的是变量本身,可当左值（可赋值）
，要当左值表达式必须是返回一个内存空间（地址）
24.const，如：(不可修改但可读)
const int *p;表示p所指向的内存空间不能被修改如：*p=10;
int * const p; 指p不能被修改如：p=NULL;
25.c++中的const是一个正真的常量，c++对const进行了特殊处理（放在c++符号表中），当你直接使用a时直接从符号表中取用，
当取用该const变量地址时，会开辟一片地址赋值为a的值，C语言的不是，可以通过地址来改变const变量的值
const int a=10;
int *p=(int *)&a;
*p=21;
pritnf("%d",a);//c++中不改变，C语言中改变了
const的指针可以接受普通类型的变量，反过来便不行（普通类型的指针不能接受const变量，也不能）
**使用const指针作为函数的参数的好处，前提是在不需要改变数据的地方，这样可以接受const变量和非const变量**
26.c++中const变量一般不分配内存空间，除了引用地址&或者当做全局变量时
27.c++中的变量必须初始化后才能使用，如：vector<int> vec;//不能直接这样使用vector<int> vec(size);或者static vector<int> vec;
28.引用的语法Type& name=var（c++特有语法），如：
int a;
int &b=a;void print(int &a)//相当于把b变成a,函数里面的a也是引用
29.vector可以为空，array不可以（前面两个为顺序排列），list容器则是以一组指针相互连接（即链表）
30.迭代器定义， （容器）<类型>::iterator 变量名; 不过对于const类型容器得把iterator变为const_iterator,欲取得iterator的值则使用提领操作（*）
31.变量名相当于内存地址的门牌号，可以有多个门牌号（引用可以创建一个该变量等等的副本）
32.函数参数引用在c++中的内部实现是一个常指针如：（学好指针很重要）引用相当于c++编译器手工帮我们返回一个指针
type &a 相当于type *const a（所占用的空间大小相同，为4个字节）
**注意：函数返回的引用要根据接收变量的定义来决定返回的是指针（若定义是&或者*） 还是一个副本值
**声明引用时必须初始化
**不能建立数组的引用
**引用在这个地方不是取地址符
33指针的引用如：指针的引用可以达到二级指针的效果
34.常引用：（让变量具有只读属性,使变为const变量）
int x=20；
const int &y=x;
普通（字面量）引用：int &m=30;//30没有内存，&m是给变量（有地址的）取一个别名所以编译不通过，加上一个const的话，c++会自动给其分配内存，编译就会通过
35.函数占位参数（可以有初值），如：
void fun(int a,int b,int=0)//函数在调用的时候要写全参数
36.函数指针：
void myfunc(int ,int b){}
void (*jia)(int a,int b);//直接定义函数指针
typedef void (myTypeFunc)(int a,int b);//定义一个函数指针类型pointer to function
myTypeFunc *p=myfunc;//定义一个函数指针变量
void (num_sequence::(*pm))(int) = 0;
typedef void (num_sequence::*pm)(int);//pointer to member function必须有个class scope，并且只能通过同类对象来调用
//使用该函数指针另它指向fibonacci函数
pm p=&num_sequence::fibonacci;
37.struct与类的区别，struct不指定权限定义的时候默认是public，class默认为private；
38.把类中的函数定义与函数声明（置于头文件中）分开
class Mypoint{
	public:
		Mypoint(int x,int y):x1(x),y1(y){};
		~Mypoint(){};
	private:
		int x1;
		int y1;
};
39.当对象生命周期结束时，会调用析构函数（析构时先创建的对象后释放，想要检验可以在函数（非main函数）中定义对象）
Teacher t1();//调用的不是无参数构造函数，去掉括号才是，这样调用是错误的
Teacher t1=(1,2,3,4)//进行有参数构造函数调用可以用括号法，‘=’号法只是调用一个参数的构造函数（因为‘，’号表达式只是取最右边的值）
Teacher t1=Teacher(1,2)//这样也可以调用有参数构造函数，会产生一个匿名对象
如果类没有提供构造函数，c++会会提供一个默认操作
拷贝初始化也是一样

40.t1 = t6;//把t6赋值给t1，对象的初始化与对象的赋值是两个不同的概念

41.显式初始化的缺点（即调用函数来初始化里面的值）：
Test tarray[3];//使用显示初始化比较难，

42.（拷贝构造函数）copy初始化，用一个对象来初始化另一个对象
Test t2=t1;//利用一个对象来初始化另一个对象
Test t2(t1);//这个也是拷贝调用函数
t1=t2;//只是单纯的赋值操作，可以重载operator=(Test &rhs)

43.function call重载不懂（知道重载，不知道怎么用）

44.拷贝构造应用场景 
//这些都是c++编译器这帮大牛所规定的
（直接用类名初始化对象会产生一个匿名对象）如：Teacher(1,23,3);
//如果函数返回值是一个元素（复杂类型）,返回的是一个新的匿名对象
//如果匿名对象 初始化 另一个对象，则匿名对象转成有名对象
//如果用匿名对象 赋值给 另一个同类型的对象 则匿名对象被析构
//匿名对象可以当左值，当完左值（执行完这段语句后）后便释放
location g()//不能直接返回一个局部对象，需要进行拷贝构造产生一个匿名对象，
{
	location a;
	return a;//返回一个匿名location对象
}
int main()
{
	location b = g();//把g()提前产生的匿名对象直接给b而不是再进行拷贝构造，所以匿名对象不会被析构，因为转成了b
	b = g();//这个是赋值，这个匿名对象会被析构，执行完这句后匿名函数马上被析构掉，因为没有被赋予名字，所以得删掉该段无用内存
	Triangular(1, 2);
	system("pause");
	return 0;
}

45.若没有定义其他的构造函数时，默认的构造函数有两类，默认构造，默认拷贝构造（浅拷贝），	默认构造函数在已经在已经定义了其他构造函数时不会被调用，会显示没有此构造函数

46.浅拷贝是指直接进行简单复制（包括指针地址的简单复制）,浅拷贝会出现的错误，因为拷贝的指针变量所指向的地址是一样的，而一个对象生命周期结束时便会释放该空间，
而另一个也执行析构函数，释放一段已经释放了的空间，所以会造成错误的产生。
 
 47.在c++中static成员必须进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝，在定义时不需static（声明关键词）修饰，
 静态成员函数可以继承和覆盖，但无法是虚函数； class a{static int c;}	int a::c =0;

48.构造函数初始化列表 解决：在b类中组合了一个a类（存在有参构造函数的）对象（无法对其他对象进行直接初始化）
先执行被组合对象的构造（若有多个，则按照其定义的顺序进行构造，析构相反）
class A
{
public:
	A(int a){}//有参数的构造函数
};
class B
{
public:
	B(int x):d(x){}//只能这样初始化
private:
	A d;
};
const成员变量只能由初始化列表来进行初始化

49.在构造函数中调用构造是函数是一种危险的行为

50.C++类对象中的成员函数与成员变量第分开存储的
普通成员变量，储存在对象中，与struct变量由相同的内存布局和字节对齐
静态成员变量储存在全局变量区中
成员函数储存在代码段中 

51.成员函数后的const（放哪里不重要，都可以）修饰的是谁：
只要有const修饰就是修饰this指针，表示this指针指向的内存空间不可修改表
***如果调用了其它函数,那么其它函数也必须有 const 属性,否则就会出现 类型限定符不兼容的错误!***

52.友元函数可以调用其所定义所在的类中的私有变量，当操作数有不是该类对象而且运算符进行运算时可以互换位置便得使用友元函数，如：
Time operator*(const Time &rhs,double value)//成员函数无法实现下面的操作，因为第一个操作数限定为对象
Time operator*(double value,const Time &rhs)
**如果只是把对象当成一个整体来操作那就没有必要变为友元函数（不需要使用成员变量）
                        
53.io输入输出符重载
void operator<<(ostream &os, Complex &rhs)
{
	os << "不可支持链式输出" << endl;
}
cout<<(Complex)C（前面部分调用上面的输出重载符，返回值作为左值）<<" "<<endl;(不支持，因为左值不为ostream对象)
所以得返回一个ostream&才能支持链式输出	

54，重载数组下标，需要注意的是数组是可以当左值的，所以重载时返回的不是普通返回而应该是返回&引用；（普通返回是一个临时变量，引用可以修变量的值）

55.记住：禁止重载实现‘ - ’号进行相加操作（遵循系统逻辑）； '=','()','[]','->'操作符只能通过成员函数进行重载

56.继承的对象在进行构造时，先调用子类构造函数未执行语句马上转向父类的构造函数（执行完后）再调用子类构造函数进行最终初始化（析构正好相反）

57.利用反斜杠‘\’可以进行特殊字符的输出

58.继承分公有继承（public），私有继承(private)，保护继承(protected)（继承下来的变量也会放在子对象的对象储存区域中）
公有继承的方法和对象，私有的仍然是私有的，公有的是公有的，保护的也是保护的
私有继承的方法和对象，全部都变成私有的，但是在派生类中仍然可以调用基类protected和public函数，不过在外人看来这些函数已然变成private函数了  
保护的，除了私有的外都变成保护的，私有的当然还是私有的

59.多态对象只能调用父类（基类）里面的方法或属性

60.继承而来的属性也是在父类中进行初始化，子类的在子类构造函数中初始化（即分别初始化）
如果在父类中有参数的构造函数，那必须在子类初始化时进行构造（如：child(int i,int j):parent(i,j){}参数列表初始化）

61.继承中有组合进行构造的先后顺序
 先调用父类的构造函数，在调用组合对象的构造函数，再执行自己的成员变量的初始化，析构相反（想想没有老爹能有儿子，啊）

 62.继承中同名成员变量或者成员函数的使用
子类依旧继承父类中同名变量或者函数，不过默认的是子类中的变量或函数（没加域作用符）如：
欲修改父类中的 b变量
child ch;
ch.b=9;
ch.parent::b=0;
函数同名类似于重载（函数多态）与变量类似调用方式

63.继承中static关键字（必须分配内存）
父类中定义的边两必须进行显式初始化（在类外进行初始化）才能进行继承
构造函数不进行public修饰的话，也会默认为private
当父类构造函数是private时，继承无法进行，因为无法进行父类构造函数初始化
64.多继承语法与应用
class c:public a,public b{}
多继承的二义性（继承的类中存在相同的变量，c++编译器不能分辨是使用来哪个类的变量）
以及虚继承（在直接接触的那个类的继承时的修饰词前面加上virtual就能解决二义性问题，只能解决具有共同祖先产生的二义性问题）项目开发中已摒弃多继承
加上virtual关键字后c++编译器会给变量偷偷增加属性，从而解决二义性问题（加与不加创建（sizeof()）的对象大小不一样）
多继承最好是配合抽象类进行使用（抽象类不允许定义成员变量），才不回造成多继承的二义性问题的发生
65.多态（根据实际情况来判断重写函数的调用如果父类指针指向的是父类对象则调用父类函数，否则调用子类对象）
要使用必须在调用的函数声明或者定义之前加上virtual，父类子类函数均加上（可以父类加上，子类不加，加了提醒这个函数就是可以使用多态），
66.多态实现的三个条件（面向对象编程通用java?等）
	一.要有继承
	二.要有虚函数重写
	三.要用父类指针指向子类对象
67.动态联编和静态联编
指的是执行期编译或普通编译，不写关键字virtual就是就是静态联编
动态联编也叫迟绑定（执行期编译，c++编译器在遇到virtual时便会将该函数特殊处理）
68.如果需要通过父类指针来释放所有的子类资源，就必须使用virtual析构函数（在父类中加上，如果直接进行子类对象的释放便不需要），如：
class A:public B
A a1;
void display(B &rhs){delete rhs;}//会直接调用析构函数，不过只会调用一次父类的析构函数(没有任何多态操作)，
								//这样会造成内存泄露，在父类中加上virtual便会调用子类和父类的构造函数
69.类中函数的重写，重载，重定义
重载必须在同一个类中，子类无法重载父类的函数，父类同名函数将发生名称覆盖（就是说子类与父类有同名函数，子类无法调用父类中同名非重写函数，要调用该函数必须加上域作用符）
重写必须子类与父类的函数必须一模一样（重写分为两种，虚函数重写，如果不加上virtual则是重定义）
70.多态原理探究/
多态成立的三个条件：要有继承，虚函数重写，父类指针指向子类对象
当类中声明虚函数时，编译器会在类中生成一个虚函数
虚函数表是一个存储类成员函数指针的数据结构
虚函数表啊是由编译器自动生成和维护的

存在虚函数时，每个对象中都有一个指向虚函数表的指针vptr（提前布局）
执行时，编译器（注意是编译器）进行判断function是不是虚函数，不是就执行静态联编，是就动态联编（迟绑定）进行链接虚函数表
71.定义一个子类对象，在这个过程中，vptr的分步初始化
进行子类初始化时（如：child ch;）时，要初始化子类的vptr指针，初始化是分步
当执行父类的构造函数的时候，ch.vptr指向父类的虚函数表当父类的构造函数运行完毕后，就ch.vptr指向子类函数的虚函数表
72.面试
可以把每个成员函数定义为同时定义一个名称相同的变量虚函数，不过会影响程序执行的效率，因为virtual函数是在执行期vptr指针进行检索虚函数表之后执行的，所以没有必要把所有函数都声明为虚函数
多态的重要意义：是设计模式的基础，是框架的基石
73.child array[] = { child(1), child(2), child(3) };
	child *C;
	parent *P;
	C = array;
	P = array;
	C->print();
	P->print()；
	当进行第一次打印的时候是不存在问题的，执行C++，P++后如果子类对象的步长与父类对象的步长不等则会出现出错的现象（指向的地址并非下一个元素的入口地址），
	步长应该是看变量，要是子类中存在变量或者方法，那么字长就不一样
74.纯虚函数与抽象类（只定义函数原型）
含有（注意是含有）纯虚函数的类叫做抽象类，抽象类不能被实例化，不过能够定义指针，能继承
子类必须实现虚函数中的方法
面向抽象类编程（面向一套定义好的接口编程，也叫面向接口编程）
75.MVC思想 M指的是模型（对接厂商提供的模型），V指的是视图（main函数），C指的是控制（主框架进行控制）
76.a代表的是数组首元素的地址，&a代表整个数组的地址，他们的步长不同，如：
int a[10];
sizeof(a)==40;
sizeof(&a)==4;
a+1和&a+1不同
77.函数指针可以做函数参数，可以直接在函数参数中定义函数指针，如：
int add(int a,int b);
func(add);
int func(int (*ptr)(int a,int b))
{
}或者
typedef int(*ptr)(int a,int b);
int func(ptr myptr)
{
}
可以调用不同的函数。相当于实现了多态机制；
回调函数的本质，把函数的参数，返回值类型提前做了约定函数指针类型起到的作用，把函数参数和函数返回值提前做好约定，只要你是符合该约定的函数（可以用后来人写得函数）
78.回调函数
动态库提前定义好协议，第三方厂商根据协议进行开发，main函数集成（include头文件），调用的函数通过函数指针来调用里面函数
79.新式链表的实现
不需要考虑数据类型，只需把业务节点（不实现其他功能，只是把节点给连接上，即只有一个next指针）包含在数据节点里面，并且作为第一个元素
建立一个有头节点的链表，方便插入其他节点，如
struct Teacher
{
	LinkListNode node;//假设已经定义了LinkListNode类型，定义Teacher类型时，node的地址和Teacher变量的地址是一致的，
	//当需要把Teacher变量转换为node变量时,只需执行强制转换，如：LinkListNode *node2=(LinkListNode *)t1;(假定t1位Teacher变量)，则*node2=node
}
80.链表删除节点时，当底层库要删除业务节点时，并不知道所分配的地址是malloc还是非malloc 的（malloc和new的空间是在堆上的），只需要把它给抛出来就好，
让程序自动决定其的去和留
内存分配有四个区：常量储存区（char *ptr="mahzieiwhushisshabi.com"），静态储存区(static)，堆(malloc and new)和栈(局部变量就是储存在栈中，函数结束就会被释放)
栈上的内存在函数结束时都会被回收（常见数组就是栈内存），切记不要返回函数的地址
81.C语言实现无类型链式储存的关键是：用unsigned int 数组来储存他们的地址，利用地址就可以储存不同类型（要巧用void类型，void类型（利于隐藏数据）可以接收全部类型，再在函数内进行适当转换）
***82.软件可能有出错的地方就必须加上错误码，使程序便于约阅读
	  在分配内存的地方最好进行判断并且初始化
	  变量定义为void* 类型时表示为无类型的地址块利于进行地址转换，很方便
	  底层开发必须注意警告，修改到无警告
83.cin出错举例如：
要求输入的是int型值，而输入的是345a，这时cin并没有出错（只有完全不匹配时才会出错），而是把345存入变量中，a在下次输入数据时再流入（要是数据输入并非char型别就会出错！cin==true）
if(!cin)
{
	cin.clear();//清除错误标记
	while(cin.get()!='\n')//get()获取输入输出缓存区的一个字符
	continue;
}//指的是发生错误时，清除错误标记，进行缓存区的清理，一直到读取到'\n'处，使下一次输入可用
85.树的遍历（先中后序遍历所遍历的路径是一样的，输出不同是因为他的访问时机不同）
而对树的操作基本上都要遍历树，以上结论可知，判断的顺序不是唯一的，相当于先中后序遍历一遍而已
86.模板类中类型可以装基本数据类型，自建数据类型，指针，模板建立struct，class均需要在他们使用的时候加上 <类型>
87.二叉树的线索化，是为了像链表一样遍历树（目的是按照遍历的顺序连接起每个节点）
二叉线索树：要是节点的左子树为空则接到遍历时的前驱节点，右孩子为空则接到这个节点遍历时的后继节点（说了遍历当然有先中后序遍历，所以也有三种线索树）
归结：两个指针的交替，前指针的左指针域指向的是前驱节点，后指针右指针域指向前驱节点，因为后指针为前一个指针上次遍历的地方，
所以这样就把该节点的左右指针域都访问且线索化了（自己想想，这个只是一种实现方法而已）
88.哈夫曼树实现数据的压缩：
数据在计算机中存储为二进制码（ASCII编码），利用哈夫曼可以有效的实现数据的压缩，比如一串字符出现次数的多少（相当于哈夫曼树中的权值），来建立用哈夫曼树表示这些字符，相比于原来整体会减少内存的使用
89.冒泡排序和选择排序
冒泡排序是相邻的元素的比较，先得出最大或者最小，选择是指选择一个最大或者最小的放在前
90.有模板的实现的头文件
不能直接包含在引用它的文件中在头文件中包含函数实现的文件，或者不包含头文件，包含其具体实现文件便可，或者定义和声明都置于头文件中
还需注意传（自建类型?有待参议）参数给模板函数，不能直接扔地址给模板指针，得定义一个指针变量指向地址之后把它传入
91.pArray[pos] = t;//stl元素保存是通过复制机制实现的，所以你的类得实现复制功能才行，即重载=号运算符
92.函数模板和类模板:	template<typename或者class 类型名.....>
让类型参数化，适合程序员编程，减少代码重用
template告诉编译器我要用模板进行编程了，不要轻易报错
函数模板显式类型调用：func<int>(x,y)常用！！！
函数模板自动类型推导：func(x,y)不好用？原因不知道
函数模板也可以重载：（调用规则如下）  
函数模板在进行函数调用时，进行*严格*的类型匹配（本质是类型参数化，不会进行类型转换），普通函数会进行一个隐式的类型转换
接上，当函数模板与普通函数都与参数匹配时，优先调用普通函数，若想调用函数模板：func<>(a,b) 使用<>类型列表便可;
***函数模板两次编译（这个也是出现第90条那种错误的原因，类模板时）
第一次根据函数模板进行简单的句法语法词法分析，产生一个简陋的函数模板原型
第二次根据函数的调用来产生具体的函数原型，调用模板函数（不同类型）的有多少就会产生多少具体原型（汇编中存在的名字不一样，所以可以跟普通函数进行重载，重载函数在汇编中的名字就是不一样的）
虽然在c++源代码里头，函数名一样，但在汇编里头，label（函数名）跟参数相关，通俗点说，在汇编之后函数名不一样。
93.普通子类从父模板类派生时，需要具体化模板类，c++编译器需要知道父类的具体类型，才知道怎么分配内存，语法如下所示：
class B:public A<int>
B() :A<int>(10)//最好加上<>
{
}
94，
模板类所有函数写在类的内部（友元函数也是），这样不会出错
写在外部时，友元函数（<< or >>）在类中的声明必须为：friend ostream& operator<< <T>(ostream &os, Complex &rhs); <<符号后加上 <类型名> 如果函数定义直接写在类内部就不用
不加出现错误是: 错误	1	error LNK2019: 无法解析的外部符号 (模板函数的二次编译造成的，两次编译成的函数头不一样，编译器不知道往哪里找)
在不需要使用友元函数的时候最好不要使用友元函数，不然会引来不必要的错误（特别在类模板中）,滥用友元函数，得在前部加上函数声明和类声明，以及上面的友元函数声明处加上<类型名>,才不会出错
结论：最好不要在模板类中使用友元函数，以及不要滥用友元函数

95.函数模板的static关键字(必须初始化)，每个家族（int，float....）使用自己家的static成员，如：
类内:static int total;
类外初始化:
template<typename T>
int 域名<T>::total=10;

95.STL中的容器进行赋值时是浅拷贝，所以要加到容器里面的类，必须支持拷贝工作（浅拷贝），即不能存在成员指针变量;或者自己实现拷贝运算符的重载
实现模板类的输出得实现2种，指针输出，引用输出

96.强制类型转换：（各司其职，尽量少使用）
static_cast<>():静态类型转换<>里面是转换到的类型（类型之间有一定关联的），()里面需要转换的参数；
		c语言中隐式转换的地方，均可以使用static_cast ,若非，使用它，编译时编译器会做类型检查，若有错误，提示错误；
reinterpret_cast<>():允许将任何指针转换为任何其他指针类型。也允许将任何整数类型转换为任何指针类型以及反向转换，用reinterpret_cast<>()进行重新解释，很强的转换（指针类型之间不需要有任何关系就可以转换）
dynamic_cast<>():运行时类型识别（RIIT），多态间的类型转换如：Dog *p=dynamic_cast<Dog>(base);如果失败就返回NULL
const_cast<>():<>里面为修改成的类型，()里面为变量；去掉变量的只读属性（const），程序员必须确定该内存空间是可以修改的（常量区就不能修改），不然后果很严重

97.抛异常是以类型作为依据的，接异常也是按照类型为依据
语法：
try{
....//语句
}
catch(异常类型)// catch(...) 表示接受未知类型异常
{
	
}
抛异常是跨函数的，不会向下执行，从中断处开始抛出到可以接收的地方（其余函数均被跳过），最终异常必须被处理，可以在catch里面把异常继续向上抛出，直到异常可以被处理
若有异常则由throw来**创建一个异常对象**并抛出
接异常是**严格**的按照类型来匹配的
异常的引发和异常的处理不必在一个函数中，但是一定要处理异常
栈解旋就是把异常发生后在栈内的内存释放掉（相当于return语句，但是可以跨越函数，也就是释放多个函数栈）

98.抛异常语法（用引用接收异常不用自己做多余的工作）
void func()throw (int ,char){}//表示能抛且只能抛出int，char类型的异常
void func1()throw(){}//表示不抛出任何类型的异常
函数头后不写throw表示可以抛出任意异常
抛出类时得注意，无参构造时，必须加上(),与普通建立对象时的构造函数不一样的使用 
如果接收class类型的异常时，若使用的是异常变量则进行拷贝构造，若使用的是引用则会使用throw的那个对象
接收异常时，指针可以和引用/元素写在一块（即一个捕捉引用，一个捕捉指针），引用不可以和元素写在一块
抛出的异常对象的生命周期，异常处理完成后异常对象就会被释放。

99.引用内部类的方法，引用时加上类限定符

	class eNegative{};
	class eZero{};
	class eTooBig{};
	class eTooSmall{};
	class eSize{};
	
100.io输入输出流（看别人理解不如直接看iostream的源代码）
cin输入的数据不接收空格，cin.get()也不接收，cin.getline(buf,256(个数))可以接收空格键，而且遇到换行符就结束，仅能读取一行数据
cin.get(a).get(b).get(c)支持链式编程，看他们的源码可知，返回的是&引用，故可以接受链式编程（前提是接收的是char类型的输入）
cin.ignore(n):忽略缓冲区n个字符
cin.peek():偷窥缓冲区中看有没有数据，如 char a=cin.peek();
cin.pushback():把取出的一个数据放回缓冲区

cout.put():
cout.write()://输出字符串
cout.flush():

101.文件io流
输入流读取文件信息
输出流向文件写入信息
#include"fstream"//包含头文件
ofstream fout(文件名);//创建一个输出流对象和文件关联，后面可以添加控制流例如：ofstream fout(文件名，ios::app)
fout<<"hello world!"<<endl;//输出到文件中
fout.close()//关闭文件
ifstream fin(文件名);//创建一个输入流对象和文件关联
char ch;
while(fin.get(ch))//读文件，与cin用法类似
{
	cout<<ch;
}
对象的序列化就是以二进制的方式储存对象 ostream fout(fname,ios::binary);
102.string类at()函数能够抛出异常
string s1("happy");
for(int i=0;i<s1.length();i++)
{
	cout<<s1[i];//不会抛出异常，出现错误会引起程序中断
	cout<<s1.at(i);//会往外面抛出异常，也可以输出
}
string 类中封装了char*，使其露出来s1.c_str();string转换成char* 类型
string的各种函数：（可以用迭代器代表他们的位置）
find():找到特定字符串，返回其初始下标
replace():替代从某一定点开始的，几个字符，替换为指定字符串
erase():擦除从当前位置开始的n个字符，返回其之后的迭代器
insert():0和1代表头插或者尾插，插入特定字符;
transform():该函数不是必须string对象调用，参数为 开始位置  结束位置   接收改变的字符的位置  函数指针(toupper转换为大写和tolower转换为小写，或者自己实现的功能，原型为：char func(char ch))
103.vector的api函数
数组元素的尾部添加：push_back()，vector<int> vec(10)//无须初始化，初始化后，会直接插在11个元素上;
获取尾部元素:back();
获取头部元素：front();也可改变头部元素如：v.front()=11;
尾部弹出元素：pop_back();
正向迭代器和逆向迭代器（iterator和reverse_iterator）,使用方法类似，一个可以正向遍历容器，一个逆向，函数多加了个r如：rbegin();等
erase():删除指定位置元素，返回后一个元素下标，必须接，当然有重载
v1.insert(v1.begin(), 12);头部插入元素
v1.insert(v1.end(), 123);尾部插入元素
distance(迭代器始位置，末位置)//计算出两位置的差
104.deque（双端数组）
与vector使用差不多，因为为双端容器所以加了，在头部弹出数据（pop_front），从头部插入元素（push_front）等； 
105.stack的api函数
push(元素):压栈
pop():弹栈；
top():获取栈顶元素
empty():栈是否为空
size():获取大小
106.queue
push(元素):往队尾添加元素
pop():弹出队头元素；
front():获取队头元素
empty():队是否为空
size():获取大小
107，list（双端链表容器），不支持迭代器的跨越变化，如：list<int>::iterator it=li.begin();  it+=5;
push_back():
pop_back():
push_front():
pop_front():
insert():插入元素
erase():清除元素
clear():清空链表
108.set（元素唯一，自动排序默认为从小到大 less<int> ，不能按照[]方式插入元素）
set<int,greater<int> > set1;
仿函数(类重载函数操作符()，能实现与函数类似的功能，所以叫仿函数) set<Student,student>看好大小写
struct student{
	bool operator()(Student &rhs1,Student &rhs2)
	{
	}
};
set插入数据时，返回一个pair对组pair<iterator,bool> pair1; pair1.second代表的是第一个量，使用别人的函数必须判断返回值
看文档吧！！！
109.返回两个值的数据类型pair
pair.first指向第一个元素
pair.second指向第二个元素
110.map<key,value>容器(key唯一)
插入元素:
map<int, string> map1;//不局限于一对元素，可以有三个四个
	//方法一
	map1.insert(pair<int, string>(1, "teacher1"));
	map1.insert(pair<int, string>(2, "teacher2"));
	//方法二
	map1.insert(make_pair(4, "teacher4"));
	map1.insert(make_pair(3, "teacher3"));
	//方法三
	map1.insert(map<int, string>::value_type(5, "teacher5"));//前三种方法返回的都是pair（类set）,若key已经存在即报错
	map1.insert(map<int, string>::value_type(6, "teacher6"));
	//方法四
	map1[7] = "teacher7";//如果key应存在就覆盖value
	map1[8] = "teacher8";
111.multimap,一个key能对应于多个value（可以进行数据分类）
count(key)//计算值为key的个数
find(key)//找到值为key的地址，返回一个泛型指针
112.所有容器存取都是值语义，而非引用语义（即实现的是浅拷贝，而不是深拷贝）
即存储的元素必须可以拷贝，或者提供拷贝构造函数以及实现‘=’操作符
113.函数对象
在一个类中重载了函数调用操作符()就叫函数对象
函数对象与普通函数的不同，函数对象可以保存类的状态信息
for_each()算法中，函数对象（或回调函数）做函数参数（实现函数对象里面的功能）,返回一个函数对象
for_each()算法中，函数对象当返回值
114.谓词
返回值为bool类型的函数对象(或函数)，有一元谓词，二元谓词，元代表函数参数
115.operator[] 的重载必须实现两个版本的重载（const和no-const）
可以通过const来实现非const版本，调用时必须进行*this的强制转换为const型（static_cast<const leixing>(*this)），不然会递归调用非const版本的[]
116.transform（可以实现转换功能，如字符串大小写转换）
参数，源容器begin(),end(),目标容器begin(),函数对象（函数指针），把返回值存进目标容器中//其中一个实现
117.plus<T> 头文件中functional中预定义函数对象
可以实现数据之间的相加（如：string类的，int的）
	plus<int> p1;
	int x = 10;
	int y = 20;
	int z=p1(x, y);//p1就是函数对象，重载了()运算符
	
118.绑定适配器（bind2nd，bind1st）
把预定义函数对象（只能是预定义函数对象才能使用）和参数进行绑定，如：bind2nd(equal_to<string>(),"aaa");//表示绑定equal_to()函数的第二个参数为“aaa”（第一个参数默认为容器的数据）
bind1st(op,value)
bind2nd(op,value)
取反器
not1(op);//not1翻转一元预定义函数对象的真值（取反），已经绑定了一个参数的函数对象算是一个参数
not2(op);//not2翻转二元预定义函数对象的真值

119.tranform 和for_each 的比较
transform中的函数对象必须有返回值，函数对象参数一般不使用引用（它的源码决定的，有赋值操作），所以速度较慢
for_each中函数对象可以没有返回值，并且参数一般为引用
输出流迭代器可以直接运算结果直接输出到屏幕上   transform(.begin(),.end(),ostream_iterator<T>(cout,"  "),函数对象);
120.查找的函数
adjacent_find()默认是查找第一个重复元素的位置(返回的是iterator)，用distance()可以得出位置
binary_search()二分法查找元素,返回bool型
count()统计出现次数,对基础类型进行查找
count_if()可以对自定义类型，最后一个参数是谓词
find()进行基础类型元素查找
find_if()自定义的查找，谓词
121.排序算法
sort()可以为任意类型数据
merge()两个有序数组的合并排序(必须是有序的，不然发生运行期异常)
random_shuffle()把任意类型的数据打乱顺序
reverse()倒序（没有排序）
122.拷贝替换算法
copy()
repalce()
repalce_if()可以按照条件进行替换
swap()交换两容器的数据
123.
fill(.begin(),.end(),填充数据)元素填充
124.UML类图
实现关系（realization）指接口的实现（在c++中指抽象类的实现）
继承关系（generalization）指继承
依赖关系（depandency）指的是，一个类是另一个的函数参数或者返回值
关联关系（diret...） 类中含有类对象作为他的成员变量（你是我私有的意思）也包含以下两个关系，表示更强的关联关系
	聚合：无生命的表示（可以由其他不同的部分组成，关系没有那么强烈，可以更换零配件，如：汽车和引擎(可以是其他不同弄产商的引擎)）
	组合：有生命的表示（缺少一个都不行，是一个整体，不可更换，如：人和五脏六腑）
125.尽量使用组合而不是继承（集成在类中）
126.创建一个单例（该程序类给对象只有一份）
懒汉式（要使用时才定义对象）：类中包含一个本类静态对象，把构造函数（两个）私有化，建立一个static函数获取该static对象，要是还没有创建就new对象，否则直接返回该对象；释放内存，同样需要一个静态函数进行释放；
饿汉式（直接进行static变量的初始化）：与上面一样，开头便初始化，获取对象函数中，减少判断的一环(易知)，直接返回；
饿汉式缺点在不使用时也会分配内存，浪费内存
懒汉式缺点，有判断过程速度变慢，在多线程时，会存在资源竞争的问题（不同线程初始化时，可能创建多个不同的对象）
127.
多线程，从创建线程的地方起，父进程继续向下执行，子线程执行其线程函数
多进程，从创建进程（fork()）的地方起，变成多个进程同时向下执行下面的代码
WaitForSingleObject(hThread[i], INFINITE);//参数 ：创建线程时返回的句柄 ，等待时间pthread_join(ptid)
主进程调用该函数，表示要等待所有子线程结束在往下执行，当有子线程执行时，系统内核发来挂起信号，该进程被挂起，直到子进程全部结束，再拉进系统的等待队列中等待执行
没有该句代码可能会产生的问题是：父进程执行完后，子线程会被强制结束
128.可以添加代码，不能直接改动原有代码
面向抽象类编程（事物可以进行割分，就可以进行抽象，比如建造者有建造平房的，建造别墅的，人有男人，女人）
129.（代码在设计模式中）
1.工厂模式案例:工厂生产水果（每个工厂只能生产一种水果）
2.抽象工厂模式案例:生产多种水果（把工厂也抽象化为可以多种水果工厂）
3.建造者模式案例:建房子（别把建造权交给客户，施工队可以进行分解也就是抽象化）
4.代理模式案例:当当网买书（A类包含B类来执行B类的功能，也就是代打）
5.装饰模式案例:车添加功能跑，飞，游（A类包含B类来执行B类的功能，同时实现自己的功能，再把它放进协议函数里面扩展功能），如：
	class C{virtual void dothing()=0;};   class B:public C{virtual void dothing(){跑}}  class A:public C{ A(C *c):m_c(c){}  void fly(){}  virtual void dothing(){fly();  m_c.dothing();}    private:C *c;};
6.适配器模式案例:给电脑供电（把一个不适用的接口转换为另一个适用的接口）
7.桥接模式案例:汽车和发动机（多和多之间的关系）
8.模板模式案例:建造车子（把业务逻辑集成在抽象类中）
NVI机制（模板模式下的案例，好处是可以集成业务逻辑，如需加锁只需要在基类中修改代码），例如
	class Base{  
	public:  
	void Foo(){  //模板，实现业务逻辑，公有非虚函数
	DoFoo1();  
	DoFoo2();  
	}//use DoFooX()  
	private:  
	virtual void DoFoo1(){  //实现默认功能，私有虚函数
	cout << "Base's DoFoo1" <<endl;  
	}  
	virtual void DoFoo2(){  
	cout << "Base's DoFoo2" <<endl;  
	}  
	};  
	class Derived: public Base{  
	private:  
	virtual void DoFoo1(){  //重写virtual private函数，但不可以被子类调用
	cout << "Derived's DoFoo1" << endl;  
	};  
	}; 
9.命令模式案例:医生看病（医生，命令和护士姐姐）
10.责任链模式案例:车子的组装
11.策略模式案例:加密算法（策略接口加上策略的封装类(组装了策略在里面)）
12.中介模式案例:男女找对象（中介者里面组装有男女对象的引用男女组装了中介者，通过中介人来寻找对象）
13.观察者模式案例:办公室警戒老板（秘书对象作为被观察者，包含诸多观察者对象(正在打机的程序员)，一有消息马上通知观察者们）
14.备忘录模式案例:备份数据（由管理者类来管理数据的备份）
15.访问者模式案例:打扫公园的各个部分（相互依赖关系）
16.状态模式案例:（完成状态之间的切换）
17.解释器模式案例:把运算结果和运算过程进行解耦合（直接关联）
18.迭代器模式案例:数组的迭代器（迭代器中直接关联数组类）

130.前置声明解决两个类的互相依赖问题，以下是需要注意的事项：
构造场景：class B;//声明式   class A{B *b;};   class B{A *a};*****0.把A类的定义放在B类的类声明后面才可以使用B类的指针或者引用（class B{A *a}; 一定得放在它的后边）
1.不能直接定义对象，可以定义对象的指针或者引用
2.不能在A类中使用B类函数
3.不能在B类定义之前调用B类的析构函数
4.当你声明一个函数他使用到某个class时，不需要class的定义，即使函数以by value方式传递参数（或者返回值）
5.继承时，被继承的类在编译时定义必须可见结论:把声明式和定义式分开

131.C语言读取文件
FILE *file = fopen(文件名,读取模式);
利用fopen打开的文件最后必须用fclose(file);关闭文件

getc(file)是获取文件单个字符内容，有记录点，记录读到了文件的哪里,读到文件尾为EOF(end of file  -1)

putc(字符,file)是往文件中写入一个字符

int main(int argc, char **args)
{

}
参数args是指在执行可执行文件的时候的要求的参数，如(copy  a.txt  b.txt)
argc代表加上自身的参数个数，如上例就有3个参数

fgets(读取的字符串,读取最大长度,file)读取文件中一行字符串，feof(file)代表结束

fputs(字符串,file)把字符串写入文件

int seq;
char buf[1024] = { 0 };
sprintf(buf,"%d",seq);//把数字转化为字符串malloc和realloc（接着malloc后分配的内存）132.智能指针（别把this指针放进去，因为你不知道智能指针何时把你的this析构掉）(#include <memory.h>)auto_ptr的几点注意事项：（auto_ptr是独占的，同一个指针同时只可以存在一个对象中）	1、auto_ptr不能共享所有权(赋值会造成所有权转移，原本的指针指向变为NULL)	2、auto_ptr不能指向数组（auto_ptr的析构函数是delete ptr; 而不是 delete []ptr;）	3、auto_ptr不能作为容器的成员 (不能进行拷贝)	4、不能通过复制操作来初始化auto_ptr	std::auto_ptr<int> p(new int(42)); //OK	std::atuo_ptr<int>p = new int(42);//Error	这是因为auto_ptr的构造函数被定义了explicit(#include "boost/shared_ptr.hpp")boost::shared_ptr<T>：	1.在使用引用计数的机制上提供了可以共享所有权的智能指针（当调用赋值运算符或者拷贝构造函数时，引用计数加一）	2.调用直接用指针构造的构造函数时，引用计数初始化为1（也就造成多次使用相同指针构造对象时，当一个对象被析构后就会发生错误）	3.当引用计数为0时，释放指针内存	4.shared_ptr可以用来容纳多态对象（意思是可以使用子类指针来初始化父类智能指针对象）	5.线程安全	6.可被放入标准库的一般容器（vector，list等）(#include "boost/weak_ptr.hpp")boost::weak_ptr<T>:	1.weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，	  它的构造和析构不会引起引用记数的增加或减少。没有重载*和->但可以使用lock获得一个可用的shared_ptr对象。	2.可以解决循环引用问题(弱引用智能指针，不会进行引用计数)(#include "boost/scoped_ptr.hpp")boost::scoped_ptr<T>:	boost::scoped_ptr 用于确保动态分配的对象能够被正确地删除。scoped_ptr 有着与std::auto_ptr类似的特性，	而最大的区别在于它不能转让所有权而auto_ptr可以。事实上，scoped_ptr永远不能被复制或被赋值！scoped_ptr 拥有它所指向的资源的所有权，	并永远不会放弃这个所有权。scoped_ptr的这种特性提升了我们的代码的表现，我们可以根据需要选择最合适的智能指针(scoped_ptr 或 auto_ptr)。